# Error ConcurrentModificationException

## Giới thiệu
**ConcurrentModificationException** xảy ra khi chúng ta **thay đổi cấu trúc collection** (add, remove)
trong khi đang **duyệt nó bằng iterator hoặc for-each**.

Đây là lỗi runtime phổ biến khi làm việc với `List`, `Set`, `Map`.

---

## Nội dung

1. [ConcurrentModificationException là gì?](#1-concurrentmodificationexception-là-gì)  
2. [Nguyên nhân gây ra lỗi](#2-nguyên-nhân-gây-ra-lỗi)  
3. [Ví dụ lỗi thường gặp](#3-ví-dụ-lỗi-thường-gặp)  
4. [Cách khắc phục lỗi](#4-cách-khắc-phục-lỗi)  
5. [Tổng kết](#5-tổng-kết)  

---

## 1. ConcurrentModificationException là gì?

Lỗi xảy ra khi:
- Một thread (hoặc cùng thread)
- Vừa **duyệt**
- Vừa **thay đổi collection**

---

## 2. Nguyên nhân gây ra lỗi

```java
List<Integer> list = new ArrayList<>(List.of(1, 2, 3));

for (Integer i : list) {
    list.remove(i); // lỗi
}
```

---

## 3. Ví dụ lỗi thường gặp

```java
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    Integer i = it.next();
    list.remove(i); // ConcurrentModificationException
}
```

---

## 4. Cách khắc phục lỗi

### 4.1 Dùng Iterator.remove()

```java
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    it.next();
    it.remove();
}
```

### 4.2 Dùng removeIf()

```java
list.removeIf(i -> i > 1);
```

### 4.3 Dùng Collection thread-safe

- `CopyOnWriteArrayList`
- `ConcurrentHashMap`

---

## 5. Tổng kết

- Không modify collection khi đang for-each
- Dùng `Iterator.remove()` hoặc API an toàn
